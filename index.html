<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sloshing Survival: Akari's Physics Lab</title>
    <style>
        :root { --bg: #0a0a0a; --accent: #00f2ff; --danger: #ff3366; --text: #e0e0e0; --gold: #ffd700; }
        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; align-items: center; height: 100vh;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 10; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        .top-bar { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: auto; }
        .timer { font-size: 3rem; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 0 0 10px var(--accent); }
        .status { font-size: 0.9rem; letter-spacing: 2px; color: var(--accent); margin-top: 5px; }
        
        .mute-btn {
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--accent); color: var(--accent);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.2rem; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; margin-left: 10px;
            vertical-align: middle; transition: 0.3s;
        }
        .mute-btn:hover { background: var(--accent); color: #000; }

        .controls-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 420px; background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px); padding: 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); pointer-events: auto;
            display: flex; flex-direction: column; gap: 15px;
        }
        .slider-group label { font-size: 0.85rem; color: var(--accent); display: flex; justify-content: space-between; }
        .risk-meter { font-weight: bold; }
        input[type=range] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn {
            background: transparent; border: 2px solid var(--accent); color: var(--accent);
            padding: 10px 20px; border-radius: 30px; font-size: 0.9rem; cursor: pointer;
            transition: 0.3s; font-family: inherit; flex: 1; min-width: 100px; text-align: center;
        }
        .btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
        .btn.cheat { border-color: var(--gold); color: var(--gold); }
        .btn.cheat.active { background: var(--gold); color: #000; box-shadow: 0 0 15px var(--gold); }
        .btn.sip { border-color: #fff; color: #fff; }
        .btn.sip:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.start { background: var(--accent); color: #000; font-weight: bold; border: none; box-shadow: 0 0 10px var(--accent); }
        .btn.start:hover { transform: scale(1.05); }

        /* Overlay & Result */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px; transition: opacity 0.5s;
        }
        #resultImage { max-width: 80%; max-height: 45vh; border-radius: 15px; box-shadow: 0 0 30px rgba(0,0,0,0.5); margin-bottom: 20px; display: none; }
        .title { font-size: 1.8rem; letter-spacing: 4px; color: var(--accent); margin-bottom: 10px; }
        .desc { font-size: 1rem; max-width: 500px; line-height: 1.6; color: #ccc; margin-bottom: 30px; }
    </style>
</head>
<body>

<canvas id="simCanvas"></canvas>

<div id="ui-layer">
    <div class="top-bar">
        <div style="display: inline-block;">
            <div class="timer" id="timerDisplay">10.00</div>
        </div>
        <button class="mute-btn" id="muteBtn" onclick="toggleMute()">ğŸ”‡</button>
        <div class="status" id="statusDisplay">READY TO START</div>
    </div>

    <div class="controls-panel" id="controls">
        <div class="slider-group">
            <label>WALKING PACE: <span id="paceLabel">æ™®é€š</span> <span class="risk-meter" id="riskMeter">â˜…â˜…â˜…â˜†â˜†</span></label>
            <input type="range" id="paceSlider" min="1" max="5" step="1" value="3">
        </div>
        <div class="btn-group" id="preGameBtns">
             <button class="btn sip" id="preSipBtn" onclick="preGameSip()">æ¸›ã‚‰ã—ã¦é–‹å§‹ (é£²ã‚€)</button>
             <button class="btn start" id="startBtn" onclick="startGame()">START OPERATION</button>
        </div>
        <div class="btn-group" id="inGameBtns" style="display:none;">
            <button class="btn cheat" id="cheatBtn" onclick="toggleCheat()">CUP: NORMAL</button>
            <button class="btn sip" id="sipBtn" onclick="takeASip()">ä¸€å£é£²ã‚€ (æ®‹ã‚Š3)</button>
        </div>
        <div style="text-align:center; font-size:0.8rem; color:#888; margin-top:5px;">
            æ“ä½œ: çŸ¢å°ã‚­ãƒ¼(å‚¾ã‘ã‚‹) / ãƒã‚¦ã‚¹ / ã‚¹ãƒãƒ› | é£²ã‚€: ã‚¹ãƒšãƒ¼ã‚¹
        </div>
    </div>
</div>

<div id="overlay">
    <h2 class="title" id="overlayTitle">SLOSHING SURVIVAL</h2>
    <img id="resultImage" src="" alt="Result">
    <p class="desc" id="overlayDesc">
        ç‰©ç†æ³•å‰‡ã¨ã„ã†åã®ã€Œæ‚ªéœŠã€ã«æŒ‘æˆ¦ã›ã‚ˆã€‚<br>
        å‚¾ã‘ã™ãã‚Œã°ã€å½“ç„¶ã“ã¼ã‚Œã¾ã™ã€‚<br>
        å…±æŒ¯ã‚’ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æ“ä½œã§ã­ã˜ä¼ã›ã‚ã€‚
    </p>
    <button class="btn" id="sensorBtn" onclick="requestSensorPermission()" style="display:none; margin-bottom: 15px;">START SENSOR (Mobile)</button>
    <button class="btn" id="overlayMainBtn" onclick="closeOverlay()">ENTER LAB</button>
</div>

<script>
    // --- è¨­å®š ---
    const CONFIG = {
        baseTime: 10.0, sipBonus: 5.0,
        g: 9.8, cupWidth: 150,
        cupHeight: 160,
        initialLiquidH: 80, sipAmount: 20, 
        maxSips: 3,
        dampingNormal: 0.98, dampingTsubo: 0.94,
        
        // â˜…ä¿®æ­£1: æ‰‹ãƒ–ãƒ¬ã®è³ªæ„Ÿã‚’å¤‰æ›´ (ä½å‘¨æ³¢ãƒ»å¤§æŒ¯å¹…åŒ–)
        handTremorFreq: 6,      // 15 -> 6 (ä¸å¿«ãªãƒ“ãƒªãƒ“ãƒªã‚’ãªãã—ã€ã†ã­ã‚Šã«å¤‰æ›´)
        handTremorScale: 0.15,  // 0.12 -> 0.15 (æŒ¯å¹…ã¯å¤§ãã)
        driftScale: 0.06,       // ãƒ‰ãƒªãƒ•ãƒˆã•ã‚‰ã«å¼·åŒ–
        
        // â˜…ä¿®æ­£2: å‚¾ããƒªãƒŸãƒƒã‚¿ãƒ¼è§£é™¤ (è‡ªæ»…å¯èƒ½ã«)
        keyTiltMax: 0.8,        // 0.35 -> 0.8 (ç´„45åº¦ã¾ã§å‚¾ã)
        mouseTiltScale: 2.5,    // ãƒã‚¦ã‚¹æ„Ÿåº¦UP
        
        defaultMuted: true
    };

    // â˜…ä¿®æ­£3: å…±æŒ¯å¼·åº¦(gain)ã‚’å…¨ä½“çš„ã«UP
    const PACES = {
        1: { hz: 1.2, label: "æœ€å¾è¡Œ", risk: "â˜…â˜…â˜†â˜†â˜†", gain: 0.8, impact: 15 },
        2: { hz: 2.0, label: "ã‚†ã£ãã‚Š", risk: "â˜…â˜…â˜…â˜…â˜…", gain: 2.5, impact: 30 }, // Gain 1.6 -> 2.5 (å³æ­»ç´š)
        3: { hz: 2.8, label: "æ™®é€š", risk: "â˜…â˜…â˜…â˜…â˜†", gain: 1.3, impact: 50 },
        4: { hz: 3.6, label: "æ—©æ­©ã", risk: "â˜…â˜…â˜…â˜†â˜†", gain: 0.8, impact: 65 },
        5: { hz: 4.4, label: "æ€¥ãè¶³", risk: "â˜…â˜…â˜…â˜…â˜†", gain: 0.6, impact: 85 }
    };

    let gameState = 'TITLE';
    let timeRemaining = CONFIG.baseTime;
    let lastTime = 0;
    let isTsuboMode = false;
    let sipStock = CONFIG.maxSips;
    let currentLiquidH = CONFIG.initialLiquidH;
    let currentPace = PACES[3];
    let isMuted = CONFIG.defaultMuted;
    let startTime = 0;

    let liquidAmp = 0; liquidVel = 0;
    let cupTilt = 0; let targetTilt = 0; let cupAngVel = 0;
    let keyTilt = 0; let mouseTilt = 0; let deviceTilt = 0;
    let handNoise = 0;

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusDisplay = document.getElementById('statusDisplay');
    const paceSlider = document.getElementById('paceSlider');
    const paceLabel = document.getElementById('paceLabel');
    const riskMeter = document.getElementById('riskMeter');
    const cheatBtn = document.getElementById('cheatBtn');
    const sipBtn = document.getElementById('sipBtn');
    const preSipBtn = document.getElementById('preSipBtn');
    const controlsPanel = document.getElementById('controls');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayDesc = document.getElementById('overlayDesc');
    const resultImage = document.getElementById('resultImage');
    const overlayMainBtn = document.getElementById('overlayMainBtn');
    const sensorBtn = document.getElementById('sensorBtn');
    const muteBtn = document.getElementById('muteBtn');
    const preGameBtns = document.getElementById('preGameBtns');
    const inGameBtns = document.getElementById('inGameBtns');

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const successAudio = new Audio('success.mp3');
    const failureAudio = new Audio('failure.mp3');
    successAudio.volume = 0.4; failureAudio.volume = 0.4;

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        setupInputs();
        updatePaceUI(3);
        updateMuteUI();
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent) && typeof DeviceMotionEvent.requestPermission === 'function') {
            sensorBtn.style.display = 'inline-block';
        }
        requestAnimationFrame(update);
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function setupInputs() {
        document.addEventListener('mousemove', (e) => {
            // ãƒã‚¦ã‚¹æ„Ÿåº¦å¼·åŒ–
            mouseTilt = ((e.clientX / window.innerWidth) - 0.5) * CONFIG.mouseTiltScale;
        });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keyTilt = -CONFIG.keyTiltMax;
            if (e.code === 'ArrowRight') keyTilt = CONFIG.keyTiltMax;
            if (e.code === 'Space' && gameState === 'PLAYING') takeASip();
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') keyTilt = 0;
        });
        paceSlider.addEventListener('input', (e) => updatePaceUI(e.target.value));
    }

    function requestSensorPermission() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(res => {
                if (res === 'granted') {
                    window.addEventListener('deviceorientation', (e) => {
                        if (e.gamma) deviceTilt = (e.gamma / 90) * 2.5; // ã‚¹ãƒãƒ›æ„Ÿåº¦ã‚‚å¼·åŒ–
                    });
                    sensorBtn.style.display = 'none';
                }
            }).catch(console.error);
        }
    }

    function updatePaceUI(val) {
        currentPace = PACES[val];
        paceLabel.textContent = currentPace.label;
        riskMeter.textContent = currentPace.risk;
        if(currentPace.gain > 1.2) riskMeter.style.color = 'var(--danger)';
        else if(currentPace.impact >= 50) riskMeter.style.color = '#ff8800';
        else riskMeter.style.color = 'var(--accent)';
    }

    function toggleMute() {
        isMuted = !isMuted;
        updateMuteUI();
        if(!isMuted && audioCtx.state === 'suspended') audioCtx.resume();
    }
    function updateMuteUI() {
        muteBtn.textContent = isMuted ? "ğŸ”‡" : "ğŸ”Š";
        muteBtn.style.opacity = isMuted ? "0.6" : "1.0";
    }

    function toggleCheat() {
        isTsuboMode = !isTsuboMode;
        cheatBtn.textContent = isTsuboMode ? "CUP: TSUBO" : "CUP: NORMAL";
        cheatBtn.classList.toggle('active');
    }

    function preGameSip() {
        currentLiquidH -= CONFIG.sipAmount;
        if (currentLiquidH < 20) currentLiquidH = 20;
        playSipSound();
        preSipBtn.textContent = "ã•ã‚‰ã«æ¸›ã‚‰ã™";
        draw(); 
    }

    function takeASip() {
        if (sipStock <= 0 || gameState !== 'PLAYING') return;
        sipStock--;
        sipBtn.textContent = `ä¸€å£é£²ã‚€ (æ®‹ã‚Š${sipStock})`;
        if(sipStock === 0) sipBtn.disabled = true;

        currentLiquidH -= CONFIG.sipAmount;
        timeRemaining += CONFIG.sipBonus;
        timerDisplay.style.color = 'var(--gold)';
        setTimeout(() => timerDisplay.style.color = '', 500);
        playSipSound();
        statusDisplay.textContent = "è³ªé‡å¤‰åŒ–: å…±æŒ¯ç‚¹ã‚·ãƒ•ãƒˆ";
    }

    function closeOverlay() {
        overlay.style.opacity = '0';
        setTimeout(() => { overlay.style.display = 'none'; overlay.style.opacity = '1'; }, 500);
        resetGameParams();
        gameState = 'READY';
        statusDisplay.textContent = "READY TO START";
        preGameBtns.style.display = 'flex';
        inGameBtns.style.display = 'none';
    }

    function resetGameParams() {
        timeRemaining = CONFIG.baseTime;
        liquidAmp = 0; liquidVel = 0; cupTilt = 0; cupAngVel = 0;
        sipStock = CONFIG.maxSips;
        currentLiquidH = CONFIG.initialLiquidH;
        sipBtn.disabled = false;
        sipBtn.textContent = `ä¸€å£é£²ã‚€ (æ®‹ã‚Š${sipStock})`;
        preSipBtn.textContent = "æ¸›ã‚‰ã—ã¦é–‹å§‹ (é£²ã‚€)";
    }

    function startGame() {
        if (audioCtx.state === 'suspended' && !isMuted) audioCtx.resume();
        gameState = 'PLAYING';
        startTime = performance.now();
        preGameBtns.style.display = 'none';
        inGameBtns.style.display = 'flex';
        stepLoop();
    }

    function stepLoop() {
        if (gameState !== 'PLAYING') return;
        applyStepForce();
        playFootstepSound();
        const baseInterval = 1000 / currentPace.hz;
        const jitter = (Math.random() - 0.5) * baseInterval * 0.25;
        setTimeout(stepLoop, baseInterval + jitter);
    }

    function applyStepForce() {
        const hFactor = currentLiquidH / CONFIG.initialLiquidH; 
        const currentEigenFreq = 2.0 * Math.sqrt(hFactor); 
        const freqDiff = Math.abs(currentPace.hz - currentEigenFreq);
        
        const resonanceEfficiency = 0.1 / (freqDiff + 0.05) * currentPace.gain;
        const rawImpact = currentPace.impact * (0.8 + Math.random() * 0.4);
        
        const elapsedTime = (performance.now() - startTime) / 1000;
        const warmUpFactor = Math.min(1.0, elapsedTime / 2.0);

        const dir = Math.random() > 0.5 ? 1 : -1;
        const force = dir * ( (50 * resonanceEfficiency) + rawImpact ) * warmUpFactor;
        
        liquidVel += force;

        if (rawImpact > 45) {
            statusDisplay.textContent = "âš ï¸ é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼è¡æ’ƒ! âš ï¸";
            statusDisplay.style.color = '#ff8800';
        } else if (resonanceEfficiency > 1.5) {
            statusDisplay.textContent = "âš ï¸ å…±æŒ¯å±é™ºåŸŸ! âš ï¸";
            statusDisplay.style.color = 'var(--danger)';
        } else {
            statusDisplay.textContent = "WALKING...";
            statusDisplay.style.color = 'var(--accent)';
        }
    }

    function update(timestamp) {
        const dt = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        if (gameState === 'PLAYING') {
            updatePhysics(dt);
            updateTimer(dt);
        } else if (gameState === 'READY') {
             updatePhysicsReady(dt);
        }
        draw();
        requestAnimationFrame(update);
    }

    function updateTimer(dt) {
        timeRemaining -= dt;
        if (timeRemaining <= 0) {
            timeRemaining = 0; endGame('SUCCESS');
        }
        timerDisplay.textContent = timeRemaining.toFixed(2);
    }

    function updatePhysicsReady(dt) {
        const rawTilt = [keyTilt, mouseTilt, deviceTilt].reduce((a, b) => Math.abs(a) > Math.abs(b) ? a : b);
        targetTilt = rawTilt; 
        cupTilt += (targetTilt - cupTilt) * 6 * dt; 
        liquidAmp *= 0.9; 
    }

    function updatePhysics(dt) {
        if (dt > 0.1) return;

        handNoise = (Math.sin(lastTime * CONFIG.handTremorFreq) * CONFIG.handTremorScale) + 
                    (Math.sin(lastTime * 0.5) * CONFIG.driftScale);
        const rawTilt = [keyTilt, mouseTilt, deviceTilt].reduce((a, b) => Math.abs(a) > Math.abs(b) ? a : b);
        targetTilt = rawTilt + handNoise;

        const prevTilt = cupTilt;
        cupTilt += (targetTilt - cupTilt) * 6 * dt; 
        cupAngVel = (cupTilt - prevTilt) / dt;

        const k = 30;
        let damping = isTsuboMode ? CONFIG.dampingTsubo : CONFIG.dampingNormal;
        
        const wallForce = -cupAngVel * 60; 
        const gravityForce = Math.sin(cupTilt) * 200; 
        if (isTsuboMode && Math.abs(liquidAmp) > 45) damping *= 0.85; 

        const acc = -k * liquidAmp + gravityForce + wallForce;
        liquidVel += acc * dt;
        liquidVel *= Math.pow(damping, dt * 60);
        liquidAmp += liquidVel * dt;

        // â˜…ä¿®æ­£4: ã“ã¼ã‚Œåˆ¤å®šã®å³å¯†åŒ–
        // æŒ¯å¹…(liquidAmp)ã ã‘ã§ãªãã€ã‚«ãƒƒãƒ—ã®å‚¾ãã«ã‚ˆã‚‹æ¶²é¢ã®ä¸Šæ˜‡ã‚‚è¨ˆç®—
        // å·¦ç«¯ã¾ãŸã¯å³ç«¯ã®Yåº§æ¨™ãŒ 0 (ã‚³ãƒƒãƒ—ç¸) ã‚’è¶…ãˆãŸã‚‰ã‚¢ã‚¦ãƒˆ
        const w = CONFIG.cupWidth / 2;
        const tanTilt = Math.tan(-cupTilt);
        // æ¶²é¢å·¦ç«¯ã®é«˜ã•(Topã‹ã‚‰ã®è·é›¢ã€‚è² ãªã‚‰æº¢ã‚Œã¦ã‚‹)
        const yLeft = (-currentLiquidH) - liquidAmp + (-w * tanTilt);
        // æ¶²é¢å³ç«¯ã®é«˜ã•
        const yRight = (-currentLiquidH) + liquidAmp + (w * tanTilt);

        // yãŒ0ã‚ˆã‚Šå¤§ãã„ï¼ˆç”»é¢ä¸‹æ–¹å‘ï¼‰ãªã‚‰ã‚»ãƒ¼ãƒ•ã€‚0ã‚ˆã‚Šå°ã•ã„ï¼ˆç”»é¢ä¸Šæ–¹å‘ï¼‰ãªã‚‰æº¢ã‚Œã€‚
        // ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ç³»ã§ã¯ä¸ŠãŒè² ã€ä¸‹ãŒæ­£ã€‚ã‚³ãƒƒãƒ—ç¸ã¯ y=0ã€‚
        // ã¤ã¾ã‚Š yLeft < 0 or yRight < 0 ã§ã‚¢ã‚¦ãƒˆã€‚
        if (yLeft > 0 || yRight > 0) { // yè»¸åè»¢ã—ã¦ã„ã‚‹ã®ã§ã€æ­£ã®å€¤(0ã‚ˆã‚Šä¸‹)ãªã‚‰ã‚¢ã‚¦ãƒˆã§ã¯ãªã...
                                       // å¾…ã£ã¦ã€liquidTopY = -currentLiquidH (ä¾‹:-80)ã€‚
                                       // ã‚³ãƒƒãƒ—ç¸ã¯ 0ã€‚æ¶²é¢ãŒç››ã‚Šä¸ŠãŒã£ã¦ 0 ã«è¿‘ã¥ãã€‚
                                       // åº§æ¨™ç³»: ç¸=0, åº•=160. æ¶²é¢=-80.
                                       // æº¢ã‚Œã‚‹æ¡ä»¶: æ¶²é¢Y > 0 ã§ã¯ãªã æ¶²é¢Y > 0 (åº•æ–¹å‘) ... é€†ã ã€‚
                                       // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯ä¸ŠãŒè² ã€ä¸‹ãŒæ­£ã€‚ç¸(0)ã‚ˆã‚Šä¸Šã«è¡Œãã¨è² ã«ãªã‚‹ã€‚
                                       // ã¤ã¾ã‚Š yLeft > 0 (ä¸‹) ã¯ã‚»ãƒ¼ãƒ•ã€‚ yLeft < 0 (ä¸Š) ã¯æº¢ã‚Œ? 
                                       // ã„ã‚„ã€æç”»ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã‚‹ã¨ `ctx.lineTo(x, y)`
                                       // y = -currentLiquidH + wave.
                                       // ç¸ã¯ y=0. ã¤ã¾ã‚Š y > 0 (æ­£) ã ã¨ã‚³ãƒƒãƒ—ã®ä¸­(åº•å´)ã€‚ y < 0 (è² ) ã ã¨ç¸ã‚ˆã‚Šä¸Šï¼Ÿ
                                       // é•ã†ã€åº•ãŒæç”»ã§ (0,0)ã‹ã‚‰ä¸‹ã«æã„ã¦ã‚‹ï¼Ÿ
                                       // defineCupPath: move(-w, -h). ç¸ã¯ -h (-160).
                                       // æ¶²é¢åˆæœŸå€¤: -80.
                                       // ã¤ã¾ã‚Šã€y < -160 ã«ãªã£ãŸã‚‰æº¢ã‚Œã€‚
                                       // ã—ã‹ã—drawé–¢æ•°ã§ã¯ ctx.translate(cx, cy) ã—ã¦ã„ã‚‹ã€‚
                                       // defineCupPathã§ã¯ y=0 ãŒåº•ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ (lineTo(w,0))
                                       // ã§ã‚‚ moveTo(-w, -h) ã—ã¦ã‚‹ã€‚
                                       // ã‚ã€é€šå¸¸ã‚³ãƒƒãƒ—: move(-w, -h) ... lineTo(-bot, 0).
                                       // ã¤ã¾ã‚Š y=0 ãŒåº•ã€y=-h ãŒç¸ã€‚
                                       // æ¶²é¢è¨ˆç®—: liquidTopY = -currentLiquidH (-80).
                                       // æº¢ã‚Œã‚‹æ¡ä»¶: æ¶²é¢Y < -CONFIG.cupHeight (-160).
                                       
           // å†ç¢ºèª: drawé–¢æ•°å†…
           // ctx.moveTo(-w, 100); // åº•ã®æç”»ç”¨ãƒ€ãƒŸãƒ¼?
           // defineCupPath: NORMAL: moveTo(-w, -h)... lineTo(bot, 0).
           // ã¤ã¾ã‚Š y=0 ãŒåº•ã€‚ y=-160 ãŒç¸ã€‚
           // æ¶²é¢: -80 ã‚¹ã‚¿ãƒ¼ãƒˆã€‚
           // æº¢ã‚Œã‚‹æ¡ä»¶: y < -160.

           const rimY = -CONFIG.cupHeight;
           if (yLeft < rimY || yRight < rimY) {
               endGame('FAILURE');
           }
        }
    }

    function endGame(result) {
        gameState = 'END';
        controlsPanel.style.opacity = '1';
        overlay.style.display = 'flex';
        resultImage.style.display = 'block';
        sensorBtn.style.display = 'none';
        
        overlayMainBtn.textContent = "RETRY CHALLENGE";

        if (result === 'SUCCESS') {
            overlayTitle.textContent = "MISSION CLEAR!";
            overlayTitle.style.color = 'var(--accent)';
            overlayDesc.innerHTML = "ãŠè¦‹äº‹ï¼ç‰©ç†æ³•å‰‡ã‚’å®Œå…¨ã«æŒæ¡ã—ã¾ã—ãŸã­ã€‚<br>è¨ˆç®—é€šã‚Šã®å‹åˆ©ã§ã™ã€‚";
            resultImage.src = "success.png";
            playWinSound();
        } else {
            overlayTitle.textContent = "SPILL DETECTED!";
            overlayTitle.style.color = 'var(--danger)';
            overlayDesc.innerHTML = "æ®‹å¿µ...ç‰©ç†ã®é­”ç‰©ã«é£²ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚<br>åˆ¶å¾¡ä¸èƒ½ãªã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æš´èµ°ã§ã™ã€‚";
            resultImage.src = "failure.png";
            playFailSound();
            if (navigator.vibrate) navigator.vibrate(300);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 + 80;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(cupTilt);

        function defineCupPath(isClip) {
            ctx.beginPath();
            const w = CONFIG.cupWidth / 2;
            const h = CONFIG.cupHeight;
            
            if (isTsuboMode) {
                ctx.moveTo(-w * 0.6, -h);
                ctx.bezierCurveTo(-w * 0.6, -h * 0.6, -w * 1.2, -h * 0.3, -w, 0);
                ctx.lineTo(w, 0);
                ctx.bezierCurveTo(w * 1.2, -h * 0.3, w * 0.6, -h * 0.6, w * 0.6, -h);
                if (isClip) ctx.closePath();
            } else {
                const bottomW = w * 0.7;
                ctx.moveTo(-w, -h); 
                ctx.lineTo(-bottomW, 0); 
                ctx.lineTo(bottomW, 0);  
                ctx.lineTo(w, -h); 
                if (isClip) ctx.closePath(); 
            }
        }

        ctx.save();
        defineCupPath(true); 
        ctx.clip(); 

        ctx.fillStyle = isTsuboMode ? 'rgba(0, 242, 255, 0.7)' : 'rgba(139, 69, 19, 0.9)';
        
        ctx.beginPath();
        const w = CONFIG.cupWidth / 2;
        const h = CONFIG.cupHeight;
        const liquidTopY = -currentLiquidH;
        const tanTilt = Math.tan(-cupTilt);
        const bottomW = isTsuboMode ? w : w * 0.7; 

        // å·¦ç«¯ãƒ»å³ç«¯ã®Yåº§æ¨™ï¼ˆåˆ¤å®šç”¨ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã§æç”»ï¼‰
        const yLeft = liquidTopY - liquidAmp + (-w * tanTilt);
        const yRight = liquidTopY + liquidAmp + (w * tanTilt);

        ctx.moveTo(isTsuboMode ? -w : -bottomW, 0); // åº•
        ctx.lineTo(-w, yLeft); // å·¦æ¶²é¢
        ctx.lineTo(w, yRight); // å³æ¶²é¢
        ctx.lineTo(isTsuboMode ? w : bottomW, 0); // åº•
        
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = isTsuboMode ? 'var(--accent)' : '#aaa';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        defineCupPath(false); 
        ctx.stroke();
        
        ctx.restore();
    }

    function playSound(type) {
        if(isMuted) return;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if (type === 'step') {
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if (type === 'sip') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(); osc.stop(now + 0.4);
        }
    }
    function playFootstepSound() { playSound('step'); }
    function playSipSound() { playSound('sip'); }
    function playWinSound() { if(!isMuted) { successAudio.currentTime = 0; successAudio.play().catch(e=>{}); } }
    function playFailSound() { if(!isMuted) { failureAudio.currentTime = 0; failureAudio.play().catch(e=>{}); } }

    init();
</script>
</body>
</html>