<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sloshing Survival: Akari's Physics Lab</title>
    <style>
        :root { --bg: #0a0a0a; --accent: #00f2ff; --danger: #ff3366; --text: #e0e0e0; --gold: #ffd700; }
        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; align-items: center; height: 100vh;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 10; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        .top-bar { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: auto; }
        .timer { font-size: 3rem; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 0 0 10px var(--accent); }
        .status { font-size: 0.9rem; letter-spacing: 2px; color: var(--accent); margin-top: 5px; }
        
        .mute-btn {
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--accent); color: var(--accent);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.2rem; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; margin-left: 10px;
            vertical-align: middle; transition: 0.3s;
        }
        .mute-btn:hover { background: var(--accent); color: #000; }

        .controls-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 420px; background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px); padding: 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); pointer-events: auto;
            display: flex; flex-direction: column; gap: 15px;
        }
        .slider-group label { font-size: 0.85rem; color: var(--accent); display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn {
            background: transparent; border: 2px solid var(--accent); color: var(--accent);
            padding: 10px 20px; border-radius: 30px; font-size: 0.9rem; cursor: pointer;
            transition: 0.3s; font-family: inherit; flex: 1; min-width: 100px; text-align: center;
        }
        .btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
        .btn.cheat { border-color: var(--gold); color: var(--gold); }
        .btn.cheat.active { background: var(--gold); color: #000; box-shadow: 0 0 15px var(--gold); }
        .btn.sip { border-color: #fff; color: #fff; }
        .btn.sip:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn.hazard { border-color: var(--danger); color: var(--danger); font-weight: bold; }
        .btn.hazard:hover { background: var(--danger); color: #000; box-shadow: 0 0 20px var(--danger); }

        .btn.start { background: var(--accent); color: #000; font-weight: bold; border: none; box-shadow: 0 0 10px var(--accent); }
        .btn.start:hover { transform: scale(1.05); }

        /* Overlay & Result */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px; transition: opacity 0.5s;
        }
        #resultImage { max-width: 80%; max-height: 45vh; border-radius: 15px; box-shadow: 0 0 30px rgba(0,0,0,0.5); margin-bottom: 20px; display: none; }
        .title { font-size: 1.8rem; letter-spacing: 4px; color: var(--accent); margin-bottom: 10px; }
        .desc { font-size: 1rem; max-width: 500px; line-height: 1.6; color: #ccc; margin-bottom: 30px; }
    </style>
</head>
<body>

<canvas id="simCanvas"></canvas>

<div id="ui-layer">
    <div class="top-bar">
        <div style="display: inline-block;">
            <div class="timer" id="timerDisplay">10.00</div>
        </div>
        <button class="mute-btn" id="muteBtn" onclick="toggleMute()">üîá</button>
        <div class="status" id="statusDisplay">READY TO START</div>
    </div>

    <div class="controls-panel" id="controls">
        <div class="slider-group">
            <label>WALKING FREQUENCY: <span id="paceLabel">2.1 Hz</span></label>
            <input type="range" id="paceSlider" min="0.5" max="4.0" step="0.1" value="2.1">
        </div>
        <div class="btn-group" id="preGameBtns">
             <button class="btn hazard" id="maxHazardBtn" onclick="setMaxHazard()">MAX HAZARD</button>
             <button class="btn sip" id="preSipBtn" onclick="preGameSip()">Ê∏õ„Çâ„Åó„Å¶ÈñãÂßã (È£≤„ÇÄ)</button>
             <button class="btn start" id="startBtn" onclick="startGame()">START OPERATION</button>
        </div>
        <div class="btn-group" id="inGameBtns" style="display:none;">
            <button class="btn cheat" id="cheatBtn" onclick="toggleCheat()">CUP: NORMAL</button>
            <button class="btn sip" id="sipBtn" onclick="takeASip()">‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä3)</button>
            <button class="btn hazard" onclick="setMaxHazard()" style="min-width: 50px; font-size: 0.8rem;">‚ö†Ô∏è</button>
        </div>
        <div style="text-align:center; font-size:0.8rem; color:#888; margin-top:5px;">
            Êìç‰Ωú: Áü¢Âç∞„Ç≠„Éº(ÂÇæ„Åë„Çã) / „Éû„Ç¶„Çπ / „Çπ„Éû„Éõ | È£≤„ÇÄ: „Çπ„Éö„Éº„Çπ
        </div>
    </div>
</div>

<div id="overlay">
    <h2 class="title" id="overlayTitle">SLOSHING SURVIVAL</h2>
    <img id="resultImage" src="" alt="Result">
    <p class="desc" id="overlayDesc">
        Áâ©ÁêÜÊ≥ïÂâá„Å®„ÅÑ„ÅÜÂêç„ÅÆ„ÄåÊÇ™Èúä„Äç„Å´ÊåëÊà¶„Åõ„Çà„ÄÇ<br>
        „Ç´„ÉÉ„Éó„ÅÆ8Ââ≤„Åæ„ÅßÊ≥®„Åå„Çå„ÅüÊ∂≤‰Ωì„ÄÇ<br>
        „Äå‰∏ÄÂè£È£≤„ÇÄ„Äç„Åì„Å®„ÅÆÈáçË¶ÅÊÄß„ÇíÂôõ„ÅøÁ∑†„ÇÅ„Çç„ÄÇ
    </p>
    <button class="btn" id="sensorBtn" onclick="requestSensorPermission()" style="display:none; margin-bottom: 15px;">START SENSOR (Mobile)</button>
    <button class="btn" id="overlayMainBtn" onclick="closeOverlay()">ENTER LAB</button>
</div>

<script>
    // --- Ë®≠ÂÆö ---
    const CONFIG = {
        baseTime: 10.0, sipBonus: 5.0,
        g: 9.8, cupWidth: 150,
        cupHeight: 160,
        initialLiquidH: 130, // 8Ââ≤„Çπ„Çø„Éº„Éà
        sipAmount: 25, 
        maxSips: 3,
        dampingNormal: 0.99, dampingTsubo: 0.94,
        tremorBaseAmp: 0.04, 
        driftWalkSpeed: 0.002,
        keyTiltMax: 0.7, 
        mouseTiltScale: 2.0,    
        defaultMuted: true
    };

    let gameState = 'TITLE'; 
    let timeRemaining = CONFIG.baseTime;
    let lastTime = 0;
    let isTsuboMode = false;
    let sipStock = CONFIG.maxSips;
    let currentLiquidH = CONFIG.initialLiquidH;
    let currentHz = 2.1;
    let isMuted = CONFIG.defaultMuted;
    let startTime = 0;
    let dyingStartTime = 0;

    let liquidAmp = 0; liquidVel = 0;
    let cupTilt = 0; let baseTilt = 0; let driftTilt = 0; let handNoise = 0;
    let keyTilt = 0; let mouseTilt = 0; let deviceTilt = 0;

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusDisplay = document.getElementById('statusDisplay');
    const paceSlider = document.getElementById('paceSlider');
    const paceLabel = document.getElementById('paceLabel');
    const cheatBtn = document.getElementById('cheatBtn');
    const sipBtn = document.getElementById('sipBtn');
    const preSipBtn = document.getElementById('preSipBtn');
    const controlsPanel = document.getElementById('controls');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayDesc = document.getElementById('overlayDesc');
    const resultImage = document.getElementById('resultImage');
    const overlayMainBtn = document.getElementById('overlayMainBtn');
    const sensorBtn = document.getElementById('sensorBtn');
    const muteBtn = document.getElementById('muteBtn');
    const preGameBtns = document.getElementById('preGameBtns');
    const inGameBtns = document.getElementById('inGameBtns');

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const successAudio = new Audio('success.mp3');
    const failureAudio = new Audio('failure.mp3');
    successAudio.volume = 0.4; failureAudio.volume = 0.4;

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        setupInputs();
        updatePaceUI(parseFloat(paceSlider.value));
        updateMuteUI();
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent) && typeof DeviceMotionEvent.requestPermission === 'function') {
            sensorBtn.style.display = 'inline-block';
        }
        requestAnimationFrame(update);
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function setupInputs() {
        document.addEventListener('mousemove', (e) => {
            mouseTilt = ((e.clientX / window.innerWidth) - 0.5) * CONFIG.mouseTiltScale;
        });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keyTilt = -CONFIG.keyTiltMax;
            if (e.code === 'ArrowRight') keyTilt = CONFIG.keyTiltMax;
            if (e.code === 'Space' && gameState === 'PLAYING') takeASip();
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') keyTilt = 0;
        });
        
        paceSlider.addEventListener('input', (e) => {
            updatePaceUI(parseFloat(e.target.value));
        });
    }

    function requestSensorPermission() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(res => {
                if (res === 'granted') {
                    window.addEventListener('deviceorientation', (e) => {
                        if (e.gamma) deviceTilt = (e.gamma / 90) * 2.5; 
                    });
                    sensorBtn.style.display = 'none';
                }
            }).catch(console.error);
        }
    }

    function updatePaceUI(val) {
        currentHz = val;
        paceLabel.textContent = currentHz.toFixed(1) + " Hz";
        
        const eigenFreq = calculateEigenFreq();
        const diff = Math.abs(currentHz - eigenFreq);
        
        if (diff < 0.2) paceLabel.style.color = 'var(--danger)'; 
        else if (diff < 0.5) paceLabel.style.color = '#ff8800';  
        else paceLabel.style.color = 'var(--accent)';            
    }

    function calculateEigenFreq() {
        const hFactor = currentLiquidH / CONFIG.initialLiquidH; 
        return 2.1 * Math.sqrt(hFactor); 
    }

    function setMaxHazard() {
        const eigenFreq = calculateEigenFreq();
        let targetHz = Math.max(0.5, Math.min(4.0, eigenFreq));
        paceSlider.value = targetHz;
        updatePaceUI(targetHz);
        
        statusDisplay.textContent = "‚ö†Ô∏è MAX RESONANCE SET ‚ö†Ô∏è";
        statusDisplay.style.color = 'var(--danger)';
        setTimeout(() => {
            if(gameState === 'PLAYING') statusDisplay.textContent = "WALKING...";
            else statusDisplay.textContent = "READY TO START";
            statusDisplay.style.color = 'var(--accent)';
        }, 1500);
    }

    function toggleMute() {
        isMuted = !isMuted;
        updateMuteUI();
        if(!isMuted && audioCtx.state === 'suspended') audioCtx.resume();
    }
    function updateMuteUI() {
        muteBtn.textContent = isMuted ? "üîá" : "üîä";
        muteBtn.style.opacity = isMuted ? "0.6" : "1.0";
    }

    function toggleCheat() {
        isTsuboMode = !isTsuboMode;
        cheatBtn.textContent = isTsuboMode ? "CUP: TSUBO" : "CUP: NORMAL";
        cheatBtn.classList.toggle('active');
    }

    function preGameSip() {
        currentLiquidH -= CONFIG.sipAmount;
        if (currentLiquidH < 20) currentLiquidH = 20;
        playSipSound();
        preSipBtn.textContent = "„Åï„Çâ„Å´Ê∏õ„Çâ„Åô";
        draw(); 
        updatePaceUI(currentHz); 
    }

    function takeASip() {
        if (sipStock <= 0 || gameState !== 'PLAYING') return;
        sipStock--;
        sipBtn.textContent = `‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä${sipStock})`;
        if(sipStock === 0) sipBtn.disabled = true;

        currentLiquidH -= CONFIG.sipAmount;
        timeRemaining += CONFIG.sipBonus;
        timerDisplay.style.color = 'var(--gold)';
        setTimeout(() => timerDisplay.style.color = '', 500);
        playSipSound();
        statusDisplay.textContent = "Ë≥™ÈáèÂ§âÂåñ: ÂÖ±ÊåØÁÇπ„Ç∑„Éï„Éà";
        updatePaceUI(currentHz);
    }

    function closeOverlay() {
        overlay.style.opacity = '0';
        setTimeout(() => { overlay.style.display = 'none'; overlay.style.opacity = '1'; }, 500);
        resetGameParams();
        gameState = 'READY';
        statusDisplay.textContent = "READY TO START";
        preGameBtns.style.display = 'flex';
        inGameBtns.style.display = 'none';
        
        paceSlider.value = 2.1;
        updatePaceUI(2.1);
    }

    function resetGameParams() {
        timeRemaining = CONFIG.baseTime;
        liquidAmp = 0; liquidVel = 0; cupTilt = 0; baseTilt = 0; driftTilt = 0;
        sipStock = CONFIG.maxSips;
        currentLiquidH = CONFIG.initialLiquidH;
        sipBtn.disabled = false;
        sipBtn.textContent = `‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä${sipStock})`;
        preSipBtn.textContent = "Ê∏õ„Çâ„Åó„Å¶ÈñãÂßã (È£≤„ÇÄ)";
    }

    function startGame() {
        if (audioCtx.state === 'suspended' && !isMuted) audioCtx.resume();
        gameState = 'PLAYING';
        startTime = performance.now();
        preGameBtns.style.display = 'none';
        inGameBtns.style.display = 'flex';
        stepLoop();
    }

    function stepLoop() {
        if (gameState !== 'PLAYING') return; 
        
        applyStepForce();
        playFootstepSound();
        
        const time = (performance.now() - startTime) / 1000;
        const arrhythmia = Math.sin(time * 0.8) * 0.2; 
        
        const effHz = currentHz * (1.0 + arrhythmia);
        const baseInterval = 1000 / effHz;
        
        const jitter = (Math.random() - 0.5) * baseInterval * 0.1;
        
        setTimeout(stepLoop, baseInterval + jitter);
    }

    function applyStepForce() {
        const eigenFreq = calculateEigenFreq();
        const freqDiff = Math.abs(currentHz - eigenFreq);
        
        let gain = 0;
        if (freqDiff < 0.15) { gain = 2.5; } 
        else if (freqDiff < 0.4) { gain = 1.5; } 
        else if (freqDiff < 0.8) { gain = 0.8; } 
        else { gain = 0.2; }

        const impactBase = 10 + (currentHz * 15); 
        const forceMag = (impactBase * gain) * (0.8 + Math.random() * 0.4);
        
        const dir = Math.random() > 0.5 ? 1 : -1;
        const elapsedTime = (performance.now() - startTime) / 1000;
        const warmUpFactor = Math.min(1.0, elapsedTime / 2.0);

        const force = dir * forceMag * warmUpFactor;
        
        liquidVel += force;
        
        if (gain > 2.0) statusDisplay.textContent = "‚ö†Ô∏è RESONANCE PEAK ‚ö†Ô∏è";
        else if (gain < 0.3) statusDisplay.textContent = "SAFE ZONE";
        else statusDisplay.textContent = "WALKING...";
    }

    function update(timestamp) {
        const dt = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        if (gameState === 'PLAYING') {
            updatePhysics(dt, timestamp);
            updateTimer(dt);
        } else if (gameState === 'DYING') {
            // „Çπ„É≠„Éº„É¢„Éº„Ç∑„Éß„É≥ (1/5ÂÄçÈÄü)
            updatePhysics(dt * 0.2, timestamp);
            if (performance.now() - dyingStartTime > 1500) {
                endGame('FAILURE');
            }
        } else if (gameState === 'READY') {
             updatePhysicsReady(dt);
        }
        draw();
        requestAnimationFrame(update);
    }

    function updateTimer(dt) {
        timeRemaining -= dt;
        if (timeRemaining <= 0) {
            timeRemaining = 0; endGame('SUCCESS');
        }
        timerDisplay.textContent = timeRemaining.toFixed(2);
    }

    function updatePhysicsReady(dt) {
        const rawTilt = [keyTilt, mouseTilt, deviceTilt].reduce((a, b) => Math.abs(a) > Math.abs(b) ? a : b);
        baseTilt += (rawTilt - baseTilt) * 6 * dt; 
        cupTilt = baseTilt;
        liquidAmp *= 0.9; 
    }

    function updatePhysics(dt, time) {
        if (dt > 0.1) return;

        // --- DYINGÊôÇ„ÅØÂÖ•Âäõ„ÇíÂÅúÊ≠¢ ---
        if (gameState !== 'DYING') {
            const t = time / 1000;
            const wave1 = Math.sin(t * 1.5);
            const wave2 = Math.sin(t * 4.2 + 1.0);
            const wave3 = Math.sin(t * 9.8 + 2.5) * 0.3;
            handNoise = (wave1 + wave2 + wave3) * CONFIG.tremorBaseAmp;
            driftTilt += (Math.random() - 0.5) * CONFIG.driftWalkSpeed;
            
            const rawTilt = [keyTilt, mouseTilt, deviceTilt].reduce((a, b) => Math.abs(a) > Math.abs(b) ? a : b);
            baseTilt += (rawTilt - baseTilt) * 6 * dt;
            
            const prevTilt = cupTilt;
            cupTilt = baseTilt + driftTilt + handNoise;
        } 
        
        // DYINGÊôÇ„ÅØ„Ç´„ÉÉ„Éó„ÅØÈùôÊ≠¢„Åô„Çã(or ÊÖ£ÊÄß„ÅßÂãï„Åè)„Åå„ÄÅÂÖ•ÂäõÊõ¥Êñ∞„ÅØ„Åó„Å™„ÅÑ
        const cupAngVel = (gameState === 'DYING') ? 0 : 0; 

        // ‚òÖ‰øÆÊ≠£: DYINGÊôÇ„ÅØ k „ÇíË≤†„ÅÆÂÄ§„Å´„Åó„Å¶„ÄÅÊ∂≤‰Ωì„ÇíÂ§ñ„Å∏Âêπ„ÅçÈ£õ„Å∞„Åô
        const k = (gameState === 'DYING') ? -20 : 30;
        
        let damping = isTsuboMode ? CONFIG.dampingTsubo : CONFIG.dampingNormal;
        const wallForce = -cupAngVel * 80; 
        const gravityForce = Math.sin(cupTilt) * 200; 
        if (isTsuboMode && Math.abs(liquidAmp) > 45) damping *= 0.85; 

        // ÈÅãÂãïÊñπÁ®ãÂºè
        const acc = -k * liquidAmp + gravityForce + wallForce;
        liquidVel += acc * dt;
        liquidVel *= Math.pow(damping, dt * 60);
        liquidAmp += liquidVel * dt;

        // „Åì„Åº„ÇåÂà§ÂÆö
        if (gameState === 'PLAYING') {
            const w = CONFIG.cupWidth / 2;
            const tanTilt = Math.tan(-cupTilt);
            const yLeft = (-currentLiquidH) - liquidAmp + (-w * tanTilt);
            const yRight = (-currentLiquidH) + liquidAmp + (w * tanTilt);
            const rimY = -CONFIG.cupHeight;

            if (yLeft < rimY || yRight < rimY) {
                startDying();
            }
        }
    }

    function startDying() {
        gameState = 'DYING';
        dyingStartTime = performance.now();
        playFailSound(); 
        if (navigator.vibrate) navigator.vibrate(800);
        statusDisplay.textContent = "CRITICAL FAILURE !!";
        statusDisplay.style.color = 'var(--danger)';
        paceSlider.disabled = true;
        sipBtn.disabled = true;
    }

    function endGame(result) {
        gameState = 'END';
        controlsPanel.style.opacity = '1';
        paceSlider.disabled = false;
        overlay.style.display = 'flex';
        resultImage.style.display = 'block';
        sensorBtn.style.display = 'none';
        overlayMainBtn.textContent = "RETRY CHALLENGE";

        if (result === 'SUCCESS') {
            overlayTitle.textContent = "MISSION CLEAR!";
            overlayTitle.style.color = 'var(--accent)';
            overlayDesc.innerHTML = "„ÅäË¶ã‰∫ãÔºÅÁâ©ÁêÜÊ≥ïÂâá„ÇíÂÆåÂÖ®„Å´ÊéåÊè°„Åó„Åæ„Åó„Åü„Å≠„ÄÇ<br>Ë®àÁÆóÈÄö„Çä„ÅÆÂãùÂà©„Åß„Åô„ÄÇ";
            resultImage.src = "success.png";
            playWinSound();
        } else {
            overlayTitle.textContent = "SPILL DETECTED!";
            overlayTitle.style.color = 'var(--danger)';
            overlayDesc.innerHTML = "ÊÆãÂøµ...Áâ©ÁêÜ„ÅÆÈ≠îÁâ©„Å´È£≤„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü„ÄÇ<br>Âà∂Âæ°‰∏çËÉΩ„Å™„Ç®„Éç„É´„ÇÆ„Éº„ÅÆÊö¥Ëµ∞„Åß„Åô„ÄÇ";
            resultImage.src = "failure.png";
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 + 80;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(cupTilt);

        function defineCupPath(isClip) {
            ctx.beginPath();
            const w = CONFIG.cupWidth / 2;
            const h = CONFIG.cupHeight;
            
            if (isTsuboMode) {
                ctx.moveTo(-w * 0.6, -h);
                ctx.bezierCurveTo(-w * 0.6, -h * 0.6, -w * 1.2, -h * 0.3, -w, 0);
                ctx.lineTo(w, 0);
                ctx.bezierCurveTo(w * 1.2, -h * 0.3, w * 0.6, -h * 0.6, w * 0.6, -h);
                if (isClip) ctx.closePath();
            } else {
                // --- Â§âÊõ¥ÁÆáÊâÄ: U„ÅÆÂ≠óÂûã ---
                ctx.moveTo(-w, -h); 
                // Â∑¶ÂÅ¥Èù¢Ôºö‰∏ä8Ââ≤„Åè„Çâ„ÅÑ„Åæ„ÅßÂûÇÁõ¥
                ctx.lineTo(-w, -h * 0.2); 
                // Â∑¶‰∏ãÔºö‰∏∏„Åø„Çí„Å§„Åë„Çã
                ctx.quadraticCurveTo(-w, 0, -w * 0.5, 0);
                // Â∫ïÈù¢ÔºöÂπ≥„Çâ
                ctx.lineTo(w * 0.5, 0);
                // Âè≥‰∏ãÔºö‰∏∏„Åø„Çí„Å§„Åë„Çã
                ctx.quadraticCurveTo(w, 0, w, -h * 0.2);
                // Âè≥ÂÅ¥Èù¢ÔºöÂûÇÁõ¥„Å´‰∏ä„Åå„Çã
                ctx.lineTo(w, -h);
                
                if (isClip) ctx.closePath(); 
            }
        }

        ctx.save();
        defineCupPath(true); 
        ctx.clip(); 

        ctx.fillStyle = isTsuboMode ? 'rgba(0, 242, 255, 0.7)' : 'rgba(139, 69, 19, 0.9)';
        
        ctx.beginPath();
        const w = CONFIG.cupWidth / 2;
        const h = CONFIG.cupHeight;
        const liquidTopY = -currentLiquidH;
        const tanTilt = Math.tan(-cupTilt);
        // UÂ≠óÂûã„Å´„Å™„Å£„Å¶„ÇÇ„Åì„Åº„ÇåÂà§ÂÆö„Å®ÊèèÁîªÂπÖ„ÅØÂ§â„Åà„Å™„ÅÑÔºàÈõ£ÊòìÂ∫¶Á∂≠ÊåÅÔºâ
        // Ë¶ã„ÅüÁõÆ‰∏ä„ÅÆÂπÖÂêà„Çè„Åõ„ÅÆ„Åü„ÇÅ w „Çí„Åù„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ
        
        const yLeft = liquidTopY - liquidAmp + (-w * tanTilt);
        const yRight = liquidTopY + liquidAmp + (w * tanTilt);

        ctx.moveTo(isTsuboMode ? -w : -w, 0); 
        ctx.lineTo(-w, yLeft); 
        ctx.lineTo(w, yRight); 
        ctx.lineTo(isTsuboMode ? w : w, 0); 
        
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = isTsuboMode ? 'var(--accent)' : '#aaa';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        defineCupPath(false); 
        ctx.stroke();

        // --- ËøΩÂä†: Âèñ„Å£Êâã„ÇíÊèèÁîª (ÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„Åø) ---
        if (!isTsuboMode) {
            ctx.beginPath();
            const w = CONFIG.cupWidth / 2;
            const h = CONFIG.cupHeight;
            
            // Â£Å„ÅÆÊ≠£Á¢∫„Å™‰ΩçÁΩÆÔºàÂè≥ÂÅ¥Èù¢„ÅØ x = wÔºâ
            // ÈñãÂßãÁÇπ„ÇíÂ£Å„ÅÆË°®Èù¢(w)„Å´Âêà„Çè„Åõ„Çã„Åì„Å®„Åß„ÇÅ„ÇäËæº„Åø„ÇíËß£Ê∂à
            ctx.moveTo(w, -h * 0.8);
            
            // Âà∂Âæ°ÁÇπ„ÅÆYÂ∫ßÊ®ô„ÇíÊé•Á∂öÁÇπ„Å®Âêå„ÅòÈ´ò„Åï„Å´„Åô„Çã„Åì„Å®„Åß„ÄÅÊ∞¥Âπ≥Ôºà0Â∫¶Ôºâ„Å´Êé•Á∂ö„Åï„Åõ„Çã
            ctx.bezierCurveTo(
                w + 50, -h * 0.8,  // CP1 (Start„Å®Âêå„ÅòY = Ê∞¥Âπ≥„Å´Âá∫„Çã)
                w + 50, -h * 0.3,  // CP2 (End„Å®Âêå„ÅòY = Ê∞¥Âπ≥„Å´ÂÖ•„Çã)
                w, -h * 0.3        // End
            );
            ctx.stroke();
        }
        
        ctx.restore();
    }

    function playSound(type) {
        if(isMuted) return;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if (type === 'step') {
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if (type === 'sip') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(); osc.stop(now + 0.4);
        }
    }
    function playFootstepSound() { playSound('step'); }
    function playSipSound() { playSound('sip'); }
    function playWinSound() { if(!isMuted) { successAudio.currentTime = 0; successAudio.play().catch(e=>{}); } }
    function playFailSound() { if(!isMuted) { failureAudio.currentTime = 0; failureAudio.play().catch(e=>{}); } }

    init();
</script>
</body>
</html>