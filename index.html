<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sloshing Survival: Akari's Physics Lab</title>
    <style>
        :root { --bg: #0a0a0a; --accent: #00f2ff; --danger: #ff3366; --text: #e0e0e0; --gold: #ffd700; }
        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none;
            display: flex; flex-direction: column; align-items: center; height: 100vh;
            user-select: none; -webkit-user-select: none;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 10; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        .top-bar { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: auto; }
        .timer { font-size: 3rem; font-weight: bold; font-family: 'Courier New', monospace; text-shadow: 0 0 10px var(--accent); transition: color 0.3s; }
        .status { font-size: 0.9rem; letter-spacing: 2px; color: var(--accent); margin-top: 5px; }
        
        @keyframes timePenalty {
            0% { transform: scale(1); color: var(--text); }
            20% { transform: scale(1.4); color: var(--danger); text-shadow: 0 0 20px var(--danger); } 
            80% { transform: scale(1.2); color: var(--danger); }
            100% { transform: scale(1); color: var(--text); }
        }
        .timer.penalty { animation: timePenalty 0.8s ease-out; }

        .mute-btn {
            background: rgba(0, 0, 0, 0.5); border: 1px solid var(--accent); color: var(--accent);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.2rem; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; margin-left: 10px;
            vertical-align: middle; transition: 0.3s;
        }
        .mute-btn:hover { background: var(--accent); color: #000; }

        .controls-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 420px; background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px); padding: 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); pointer-events: auto;
            display: flex; flex-direction: column; gap: 15px;
        }
        .slider-group label { font-size: 0.85rem; color: var(--accent); display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn {
            background: transparent; border: 2px solid var(--accent); color: var(--accent);
            padding: 10px 20px; border-radius: 30px; font-size: 0.9rem; cursor: pointer;
            transition: 0.3s; font-family: inherit; flex: 1; min-width: 100px; text-align: center;
        }
        .btn:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }
        .btn:active { transform: scale(0.95); }
        .btn.cheat { border-color: var(--gold); color: var(--gold); }
        .btn.cheat.active { background: var(--gold); color: #000; box-shadow: 0 0 15px var(--gold); }
        .btn.sip { border-color: #fff; color: #fff; }
        .btn.sip:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; color: #555; }
        
        .btn.hazard { border-color: var(--danger); color: var(--danger); font-weight: bold; }
        .btn.hazard:hover { background: var(--danger); color: #000; box-shadow: 0 0 20px var(--danger); }

        .btn.start { background: var(--accent); color: #000; font-weight: bold; border: none; box-shadow: 0 0 10px var(--accent); }
        .btn.start:hover { transform: scale(1.05); }

        .calib-btn {
            font-size: 0.75rem; border: 1px dashed var(--accent); padding: 8px; margin-top: 5px; width: 100%;
            background: rgba(0,0,0,0.3); color: var(--accent); cursor: pointer; border-radius: 10px;
        }
        .calib-btn:hover { background: rgba(0, 242, 255, 0.2); }

        /* Overlay & Result */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px; transition: opacity 0.5s;
        }
        #resultImage { max-width: 80%; max-height: 45vh; border-radius: 15px; box-shadow: 0 0 30px rgba(0,0,0,0.5); margin-bottom: 20px; display: none; object-fit: contain; }
        .title { font-size: 1.8rem; letter-spacing: 4px; color: var(--accent); margin-bottom: 10px; }
        .desc { font-size: 1rem; max-width: 500px; line-height: 1.6; color: #ccc; margin-bottom: 30px; }
    </style>
</head>
<body>

<canvas id="simCanvas"></canvas>

<div id="ui-layer">
    <div class="top-bar">
        <div style="display: inline-block;">
            <div class="timer" id="timerDisplay">10.00</div>
        </div>
        <button class="mute-btn" id="muteBtn" onclick="toggleMute()">üîá</button>
        <div class="status" id="statusDisplay">READY TO START</div>
    </div>

    <div class="controls-panel" id="controls">
        <div class="slider-group">
            <label>WALKING FREQUENCY: <span id="paceLabel">2.1 Hz</span></label>
            <input type="range" id="paceSlider" min="0.5" max="4.0" step="0.1" value="2.1">
        </div>
        
        <div class="btn-group" id="preGameBtns">
             <button class="btn hazard" id="maxHazardBtn" onclick="setMaxHazard()">MAX HAZARD</button>
             <button class="btn sip" id="preSipBtn" onclick="preGameSip()">Ê∏õ„Çâ„Åó„Å¶ÈñãÂßã (È£≤„ÇÄ)</button>
             <button class="btn start" id="startBtn" onclick="startGame()">START OPERATION</button>
        </div>
        
        <div class="btn-group" id="inGameBtns" style="display:none;">
            <button class="btn cheat" id="cheatBtn" onclick="toggleCheat()">CUP: NORMAL</button>
            <button class="btn sip" id="sipBtn" onclick="takeASip()">‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä3)</button>
            <button class="btn hazard" onclick="setMaxHazard()" style="min-width: 50px; font-size: 0.8rem;">‚ö†Ô∏è</button>
        </div>

        <button class="calib-btn" id="calibBtn" onclick="calibrateSensor()" style="display:none;">
            ‚öñÔ∏è SET ZERO (Ê∞¥Âπ≥„É™„Çª„ÉÉ„Éà)
        </button>

        <div style="text-align:center; font-size:0.8rem; color:#888; margin-top:5px;">
            Êìç‰Ωú: Áü¢Âç∞„Ç≠„Éº(ÂæÆË™øÊï¥) / „Éû„Ç¶„Çπ(Áõ¥ÊÑü) / „Çπ„Éû„Éõ | È£≤„ÇÄ: „Çπ„Éö„Éº„Çπ
        </div>
    </div>
</div>

<div id="overlay">
    <h2 class="title" id="overlayTitle">SLOSHING SURVIVAL</h2>
    <img id="resultImage" src="" alt="Result">
    <p class="desc" id="overlayDesc">
        Áâ©ÁêÜÊ≥ïÂâá„Å®„ÅÑ„ÅÜÂêç„ÅÆ„ÄåÊÇ™Èúä„Äç„Å´ÊåëÊà¶„Åõ„Çà„ÄÇ<br>
        „Ç´„ÉÉ„Éó„ÅÆ8Ââ≤„Åæ„ÅßÊ≥®„Åå„Çå„ÅüÊ∂≤‰Ωì„ÄÇ<br>
        „Äå‰∏ÄÂè£È£≤„ÇÄ„Äç„Åì„Å®„ÅØ„ÄÅÂÆâÂÖ®„Å®Âºï„ÅçÊèõ„Åà„Å´<br>Ëã¶Èõ£„ÅÆÈÅì„Çí‰º∏„Å∞„ÅôË´∏ÂàÉ„ÅÆÂâ£„ÄÇ
    </p>
    <button class="btn" id="sensorBtn" onclick="requestSensorPermission()" style="display:none; margin-bottom: 15px;">START SENSOR (Mobile)</button>
    <button class="btn" id="overlayMainBtn" onclick="closeOverlay()">ENTER LAB</button>
</div>

<script>
    // --- Ë®≠ÂÆö ---
    const CONFIG = {
        baseTime: 10.0,
        g: 9.8, 
        cupWidth: 150,
        cupHeight: 160,
        initialLiquidH: 130, 
        sipAmount: 25, 
        maxSips: 3,
        sipPenalties: [5.0, 10.0, 15.0], 
        
        dampingNormal: 0.99, 
        dampingTsubo: 0.94,
        tremorBaseAmp: 0.04, 
        driftWalkSpeed: 0.002,
        
        // ÂÖ•ÂäõÊÑüÂ∫¶
        maxTiltAngle: 0.52, 
        tiltSpeed: 0.52 / 2.0,
        mouseTiltScale: 2.0,    
        
        defaultMuted: true
    };

    let gameState = 'TITLE'; 
    let timeRemaining = CONFIG.baseTime;
    let countdownTime = 3.0; // „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥Áî®
    let lastTime = 0;
    
    let isTsuboMode = false;
    let sipStock = CONFIG.maxSips;
    let currentLiquidH = CONFIG.initialLiquidH;
    let currentHz = 2.1;
    let isMuted = CONFIG.defaultMuted;
    
    let startTime = 0;
    let dyingStartTime = 0;

    // Áâ©ÁêÜ„ÉªËßíÂ∫¶Â§âÊï∞
    let liquidAmp = 0; liquidVel = 0;
    let currentTilt = 0; 
    let targetTilt = 0;  
    let noiseTilt = 0;   
    let driftOffset = 0; 

    // ÂÖ•ÂäõÁä∂ÊÖã
    let keyInputDir = 0; 
    let mouseTargetRatio = 0; 
    let activeInputMethod = 'MOUSE'; // 'MOUSE' or 'KEYBOARD' (Á´∂ÂêàÂõûÈÅøÁî®)
    let gyroData = { gamma: 0 };
    let gyroOffset = { gamma: 0 }; 

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusDisplay = document.getElementById('statusDisplay');
    const paceSlider = document.getElementById('paceSlider');
    const paceLabel = document.getElementById('paceLabel');
    const cheatBtn = document.getElementById('cheatBtn');
    const sipBtn = document.getElementById('sipBtn');
    const preSipBtn = document.getElementById('preSipBtn');
    const controlsPanel = document.getElementById('controls');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayDesc = document.getElementById('overlayDesc');
    const resultImage = document.getElementById('resultImage');
    const overlayMainBtn = document.getElementById('overlayMainBtn');
    const sensorBtn = document.getElementById('sensorBtn');
    const calibBtn = document.getElementById('calibBtn');
    const muteBtn = document.getElementById('muteBtn');
    const preGameBtns = document.getElementById('preGameBtns');
    const inGameBtns = document.getElementById('inGameBtns');

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const successAudio = new Audio('success.mp3'); 
    const failureAudio = new Audio('failure.mp3'); 
    successAudio.volume = 0.4; failureAudio.volume = 0.4;

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        setupInputs();
        updatePaceUI(parseFloat(paceSlider.value));
        updateMuteUI();
        
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
             if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                sensorBtn.style.display = 'inline-block';
             } else {
                 calibBtn.style.display = 'inline-block';
                 window.addEventListener('deviceorientation', handleOrientation);
             }
        }
        
        requestAnimationFrame(update);
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function setupInputs() {
        // „Éû„Ç¶„ÇπÁßªÂãï: „É¢„Éº„Éâ„ÇíMOUSE„Å´„Åó„Å¶„Çø„Éº„Ç≤„ÉÉ„ÉàÊõ¥Êñ∞
        document.addEventListener('mousemove', (e) => {
            activeInputMethod = 'MOUSE';
            const ratio = (e.clientX / window.innerWidth) * 2 - 1; 
            mouseTargetRatio = Math.max(-1, Math.min(1, ratio));
        });

        // „Ç≠„ÉºÊìç‰Ωú: „É¢„Éº„Éâ„ÇíKEYBOARD„Å´„Åó„Å¶ÂÖ•ÂäõÂèó‰ªò
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                activeInputMethod = 'KEYBOARD';
            }
            if (e.code === 'ArrowLeft') keyInputDir = -1;
            if (e.code === 'ArrowRight') keyInputDir = 1;
            if (e.code === 'Space' && gameState === 'PLAYING') takeASip();
        });
        document.addEventListener('keyup', (e) => {
            if ((e.code === 'ArrowLeft' && keyInputDir === -1) || 
                (e.code === 'ArrowRight' && keyInputDir === 1)) {
                keyInputDir = 0;
            }
        });
        paceSlider.addEventListener('input', (e) => {
            updatePaceUI(parseFloat(e.target.value));
        });
    }

    function handleOrientation(e) {
        gyroData.gamma = e.gamma || 0;
        activeInputMethod = 'GYRO'; // „Ç∏„É£„Ç§„É≠„ÅåÂÖ•„Å£„Åü„Çâ„Ç∏„É£„Ç§„É≠ÂÑ™ÂÖà
        calibBtn.style.display = 'inline-block';
    }

    function requestSensorPermission() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(res => {
                if (res === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                    sensorBtn.style.display = 'none';
                    calibBtn.style.display = 'inline-block';
                }
            }).catch(console.error);
        }
    }

    function calibrateSensor() {
        gyroOffset.gamma = gyroData.gamma;
        liquidAmp *= 0.5;
        liquidVel *= 0.5;
        statusDisplay.textContent = "SENSOR ZERO SET!";
        setTimeout(() => { if(gameState==='PLAYING') statusDisplay.textContent = "WALKING..."; }, 1000);
    }

    function updatePaceUI(val) {
        currentHz = val;
        paceLabel.textContent = currentHz.toFixed(1) + " Hz";
        
        const eigenFreq = calculateEigenFreq();
        const diff = Math.abs(currentHz - eigenFreq);
        
        if (diff < 0.2) paceLabel.style.color = 'var(--danger)'; 
        else if (diff < 0.5) paceLabel.style.color = '#ff8800';  
        else paceLabel.style.color = 'var(--accent)';            
    }

    function calculateEigenFreq() {
        const hFactor = currentLiquidH / CONFIG.initialLiquidH; 
        return 2.1 * Math.sqrt(hFactor); 
    }

    function setMaxHazard() {
        const eigenFreq = calculateEigenFreq();
        let targetHz = Math.max(0.5, Math.min(4.0, eigenFreq));
        paceSlider.value = targetHz;
        updatePaceUI(targetHz);
        
        statusDisplay.textContent = "‚ö†Ô∏è MAX RESONANCE SET ‚ö†Ô∏è";
        statusDisplay.style.color = 'var(--danger)';
        setTimeout(() => {
            if(gameState === 'PLAYING') statusDisplay.textContent = "WALKING...";
            else statusDisplay.textContent = "READY TO START";
            statusDisplay.style.color = 'var(--accent)';
        }, 1500);
    }

    function toggleMute() {
        isMuted = !isMuted;
        updateMuteUI();
        if(!isMuted && audioCtx.state === 'suspended') audioCtx.resume();
    }
    function updateMuteUI() {
        muteBtn.textContent = isMuted ? "üîá" : "üîä";
        muteBtn.style.opacity = isMuted ? "0.6" : "1.0";
    }

    function toggleCheat() {
        isTsuboMode = !isTsuboMode;
        cheatBtn.textContent = isTsuboMode ? "CUP: TSUBO" : "CUP: NORMAL";
        cheatBtn.classList.toggle('active');
    }

    function preGameSip() {
        currentLiquidH -= CONFIG.sipAmount;
        if (currentLiquidH < 20) currentLiquidH = 20;
        playTone('sip'); 
        preSipBtn.textContent = "„Åï„Çâ„Å´Ê∏õ„Çâ„Åô";
        draw(); 
        updatePaceUI(currentHz); 
    }

    function takeASip() {
        if (sipStock <= 0 || gameState !== 'PLAYING') return;
        
        const penaltyIndex = CONFIG.maxSips - sipStock; // 0, 1, 2
        const penaltyTime = CONFIG.sipPenalties[penaltyIndex];
        
        sipStock--;
        sipBtn.textContent = `‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä${sipStock})`;
        if(sipStock === 0) sipBtn.disabled = true;

        currentLiquidH -= CONFIG.sipAmount;
        liquidAmp *= 0.6; 
        
        timeRemaining += penaltyTime;
        
        timerDisplay.classList.remove('penalty');
        void timerDisplay.offsetWidth; 
        timerDisplay.classList.add('penalty');
        
        playTone('sip');
        statusDisplay.textContent = `PENALTY! ÊÆã„ÇäÊôÇÈñì +${penaltyTime}Áßí`;
        updatePaceUI(currentHz);
    }

    function closeOverlay() {
        overlay.style.opacity = '0';
        setTimeout(() => { overlay.style.display = 'none'; overlay.style.opacity = '1'; }, 500);
        resetGameParams();
        gameState = 'READY';
        statusDisplay.textContent = "READY TO START";
        preGameBtns.style.display = 'flex';
        inGameBtns.style.display = 'none';
        
        paceSlider.value = 2.1;
        updatePaceUI(2.1);
    }

    function resetGameParams() {
        timeRemaining = CONFIG.baseTime;
        liquidAmp = 0; liquidVel = 0; 
        currentTilt = 0; targetTilt = 0; driftOffset = 0; noiseTilt = 0;
        sipStock = CONFIG.maxSips;
        currentLiquidH = CONFIG.initialLiquidH;
        sipBtn.disabled = false;
        sipBtn.textContent = `‰∏ÄÂè£È£≤„ÇÄ (ÊÆã„Çä${sipStock})`;
        preSipBtn.textContent = "Ê∏õ„Çâ„Åó„Å¶ÈñãÂßã (È£≤„ÇÄ)";
        timerDisplay.classList.remove('penalty');
    }

    function startGame() {
        if (audioCtx.state === 'suspended' && !isMuted) audioCtx.resume();
        gameState = 'COUNTDOWN'; // „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥„Å∏ÈÅ∑Áßª
        countdownTime = 3.0;
        preGameBtns.style.display = 'none';
        inGameBtns.style.display = 'flex';
        statusDisplay.textContent = "LEVEL YOUR CUP!";
    }

    function startWalking() {
        gameState = 'PLAYING';
        startTime = performance.now();
        stepLoop();
        statusDisplay.textContent = "WALKING...";
    }

    function stepLoop() {
        if (gameState !== 'PLAYING') return; 
        
        applyStepForce();
        playTone('step');
        
        const time = (performance.now() - startTime) / 1000;
        const arrhythmia = Math.sin(time * 0.8) * 0.2; 
        const effHz = currentHz * (1.0 + arrhythmia);
        const baseInterval = 1000 / effHz;
        const jitter = (Math.random() - 0.5) * baseInterval * 0.1;
        
        setTimeout(stepLoop, baseInterval + jitter);
    }

    function applyStepForce() {
        const eigenFreq = calculateEigenFreq();
        const freqDiff = Math.abs(currentHz - eigenFreq);
        
        let gain = 0;
        if (freqDiff < 0.15) { gain = 2.5; } 
        else if (freqDiff < 0.4) { gain = 1.5; } 
        else if (freqDiff < 0.8) { gain = 0.8; } 
        else { gain = 0.2; }

        const impactBase = 10 + (currentHz * 15); 
        const forceMag = (impactBase * gain) * (0.8 + Math.random() * 0.4);
        
        const dir = Math.random() > 0.5 ? 1 : -1;
        liquidVel += dir * forceMag;
        
        if (gain > 2.0) statusDisplay.textContent = "‚ö†Ô∏è RESONANCE PEAK ‚ö†Ô∏è";
        else if (gain < 0.3) statusDisplay.textContent = "SAFE ZONE";
        else statusDisplay.textContent = "WALKING...";
    }

    function update(timestamp) {
        const dt = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        if (gameState === 'COUNTDOWN') {
            updateInput(dt, timestamp);
            updatePhysics(dt, timestamp);
            
            countdownTime -= dt;
            if (countdownTime <= 0) {
                startWalking();
            }
        } else if (gameState === 'PLAYING') {
            updateInput(dt, timestamp); 
            updatePhysics(dt, timestamp);
            updateTimer(dt);
        } else if (gameState === 'DYING') {
            updatePhysics(dt * 0.2, timestamp);
            if (performance.now() - dyingStartTime > 1500) {
                endGame('FAILURE');
            }
        } else if (gameState === 'READY') {
             updateInput(dt, timestamp);
             liquidAmp *= 0.95; liquidVel *= 0.9;
             // READY‰∏≠„ÇÇÂÖ•Âäõ„ÅØÂèó„Åë‰ªò„Åë„Çã
             currentTilt = targetTilt; 
        }
        draw();
        requestAnimationFrame(update);
    }

    function updateTimer(dt) {
        timeRemaining -= dt;
        if (timeRemaining <= 0) {
            timeRemaining = 0; endGame('SUCCESS');
        }
        timerDisplay.textContent = timeRemaining.toFixed(2);
    }

    function updateInput(dt, time) {
        // --- „É¢„Éº„Éâ„Å´„Çà„ÇãÂàÜÂ≤êÂá¶ÁêÜ ---
        
        if (activeInputMethod === 'KEYBOARD') {
            // „Ç≠„Éº„Éú„Éº„Éâ: Áõ∏ÂØæÁßªÂãïÔºàÈÄüÂ∫¶0.4ÂÄçÔºâ
            if (keyInputDir !== 0) {
                targetTilt += keyInputDir * (CONFIG.tiltSpeed * 0.4) * dt;
            }
            // ÁØÑÂõ≤Âà∂Èôê
            targetTilt = Math.max(-CONFIG.maxTiltAngle, Math.min(CONFIG.maxTiltAngle, targetTilt));
        } 
        else if (activeInputMethod === 'MOUSE') {
            // „Éû„Ç¶„Çπ: Áµ∂ÂØæ‰ΩçÁΩÆ„Å∏„ÅÆËøΩÂæìÔºàÊÖ£ÊÄß„Å™„Åó„ÄÅ„ÉÄ„Ç§„É¨„ÇØ„ÉàÔºâ
            const mouseGoal = mouseTargetRatio * CONFIG.maxTiltAngle;
            // Á¥†Êó©„ÅèËøΩÂæì„Åï„Åõ„Çã„Åü„ÇÅ targetTilt „Çí mouseGoal „Å´Âº∑Âà∂‰∏ÄËá¥Ôºà„ÇÇ„Åó„Åè„ÅØÈùûÂ∏∏„Å´ÈÄü„ÅèË£úÈñìÔºâ
            targetTilt = mouseGoal;
        }
        else if (activeInputMethod === 'GYRO') {
            // „Ç∏„É£„Ç§„É≠: Áµ∂ÂØæ‰ΩçÁΩÆÔºà„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ËÄÉÊÖÆÔºâ
            if (gyroData.gamma !== 0) {
                let gyroTilt = (gyroData.gamma - gyroOffset.gamma) * (Math.PI / 180);
                targetTilt = gyroTilt;
            }
        }

        // ÂÖ±ÈÄöÂá¶ÁêÜ: ÊÖ£ÊÄßÂâäÈô§ÔºàcurrentTilt„Å´Áõ¥ÂèçÊò†Ôºâ
        currentTilt = targetTilt;

        // „Éé„Ç§„Ç∫‰ªò‰∏é
        const t = time / 1000;
        const wave1 = Math.sin(t * 1.5);
        const wave2 = Math.sin(t * 4.2 + 1.0);
        const wave3 = Math.sin(t * 9.8 + 2.5) * 0.3;
        noiseTilt = (wave1 + wave2 + wave3) * CONFIG.tremorBaseAmp;

        driftOffset += (Math.random() - 0.5) * CONFIG.driftWalkSpeed;
    }

    function updatePhysics(dt, time) {
        if (dt > 0.1) return;

        const k = (gameState === 'DYING') ? -20 : 30;
        let damping = isTsuboMode ? CONFIG.dampingTsubo : CONFIG.dampingNormal;
        
        let totalTilt = currentTilt + noiseTilt + driftOffset;
        if (gameState === 'DYING') {
            const sign = Math.sign(liquidAmp) || 1;
            totalTilt += sign * 1.0 * dt; 
        }
        
        const cupAngVel = 0; 
        const wallForce = -cupAngVel * 80;

        const gravityForce = Math.sin(totalTilt) * 200; 
        
        if (isTsuboMode && Math.abs(liquidAmp) > 45) damping *= 0.85; 

        const acc = -k * liquidAmp + gravityForce + wallForce;
        liquidVel += acc * dt;
        liquidVel *= Math.pow(damping, dt * 60);
        liquidAmp += liquidVel * dt;

        // COUNTDOWN‰∏≠„ÇÇ„Åì„Åº„ÇåÂà§ÂÆö„ÅØÊúâÂäπ
        if (gameState === 'PLAYING' || gameState === 'COUNTDOWN') {
            const w = CONFIG.cupWidth / 2;
            const tanTilt = Math.tan(-totalTilt);
            const yLeft = (-currentLiquidH) - liquidAmp + (-w * tanTilt);
            const yRight = (-currentLiquidH) + liquidAmp + (w * tanTilt);
            const rimY = -CONFIG.cupHeight;

            if (yLeft < rimY || yRight < rimY) {
                startDying();
            }
        }
    }

    function startDying() {
        gameState = 'DYING';
        dyingStartTime = performance.now();
        playTone('fail'); 
        if (navigator.vibrate) navigator.vibrate(800);
        statusDisplay.textContent = "CRITICAL FAILURE !!";
        statusDisplay.style.color = 'var(--danger)';
        paceSlider.disabled = true;
        sipBtn.disabled = true;
    }

    function endGame(result) {
        gameState = 'END';
        controlsPanel.style.opacity = '1';
        paceSlider.disabled = false;
        overlay.style.display = 'flex';
        resultImage.style.display = 'block';
        sensorBtn.style.display = 'none';
        calibBtn.style.display = 'none';
        
        overlayMainBtn.textContent = "RETRY CHALLENGE";

        if (result === 'SUCCESS') {
            overlayTitle.textContent = "MISSION CLEAR!";
            overlayTitle.style.color = 'var(--accent)';
            overlayDesc.innerHTML = "„ÅäË¶ã‰∫ãÔºÅÁâ©ÁêÜÊ≥ïÂâá„ÇíÂÆåÂÖ®„Å´ÊéåÊè°„Åó„Åæ„Åó„Åü„Å≠„ÄÇ<br>Ë®àÁÆóÈÄö„Çä„ÅÆÂãùÂà©„Åß„Åô„ÄÇ";
            resultImage.src = "success.png"; 
            if(!isMuted) {
                successAudio.currentTime = 0;
                successAudio.play().catch(e=>{});
            }
            playTone('win');
        } else {
            overlayTitle.textContent = "SPILL DETECTED!";
            overlayTitle.style.color = 'var(--danger)';
            overlayDesc.innerHTML = "ÊÆãÂøµ...Áâ©ÁêÜ„ÅÆÈ≠îÁâ©„Å´È£≤„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü„ÄÇ<br>„É™„Ç∫„É†„ÅåÂêà„Å£„Å¶„Åó„Åæ„Å£„Åü„Çà„ÅÜ„Åß„Åô„ÄÇ<br>„Äå„ÅÇ„ÅÑ„Åü„Åü„Äú„Äç";
            resultImage.src = "failure.png"; 
            if(!isMuted) {
                failureAudio.currentTime = 0;
                failureAudio.play().catch(e=>{});
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 + 80;

        ctx.save();
        ctx.translate(cx, cy);
        
        const drawTilt = currentTilt + noiseTilt + driftOffset;
        ctx.rotate(drawTilt);

        function defineCupPath(isClip) {
            ctx.beginPath();
            const w = CONFIG.cupWidth / 2;
            const h = CONFIG.cupHeight;
            
            if (isTsuboMode) {
                ctx.moveTo(-w * 0.6, -h);
                ctx.bezierCurveTo(-w * 0.6, -h * 0.6, -w * 1.2, -h * 0.3, -w, 0);
                ctx.lineTo(w, 0);
                ctx.bezierCurveTo(w * 1.2, -h * 0.3, w * 0.6, -h * 0.6, w * 0.6, -h);
                if (isClip) ctx.closePath();
            } else {
                ctx.moveTo(-w, -h); 
                ctx.lineTo(-w, -h * 0.2); 
                ctx.quadraticCurveTo(-w, 0, -w * 0.5, 0);
                ctx.lineTo(w * 0.5, 0);
                ctx.quadraticCurveTo(w, 0, w, -h * 0.2);
                ctx.lineTo(w, -h);
                if (isClip) ctx.closePath(); 
            }
        }

        ctx.save();
        defineCupPath(true); 
        ctx.clip(); 

        ctx.fillStyle = isTsuboMode ? 'rgba(0, 242, 255, 0.7)' : 'rgba(139, 69, 19, 0.9)';
        
        ctx.beginPath();
        const w = CONFIG.cupWidth / 2;
        const h = CONFIG.cupHeight;
        const liquidTopY = -currentLiquidH;
        const tanTilt = Math.tan(-drawTilt);

        const yLeft = liquidTopY - liquidAmp + (-w * tanTilt);
        const yRight = liquidTopY + liquidAmp + (w * tanTilt);

        ctx.moveTo(-w * 2, 0); 
        ctx.lineTo(-w * 2, yLeft); 
        ctx.lineTo(w * 2, yRight); 
        ctx.lineTo(w * 2, 0); 
        
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = isTsuboMode ? 'var(--accent)' : '#aaa';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        defineCupPath(false); 
        ctx.stroke();
        
        if (!isTsuboMode) {
            ctx.beginPath();
            const w = CONFIG.cupWidth / 2;
            const h = CONFIG.cupHeight;
            const tY = -h * 0.8;
            const bY = -h * 0.3;
            
            ctx.moveTo(w, tY);
            ctx.bezierCurveTo(w + 50, tY, w + 50, bY, w, bY);
            ctx.stroke();
        }

        ctx.restore();

        // --- ËøΩÂä†: „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ & FAILURE Ë°®Á§∫ ---
        if (gameState === 'COUNTDOWN') {
            ctx.save();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 242, 255, 0.8)';
            ctx.shadowBlur = 20;
            const count = Math.ceil(countdownTime);
            ctx.fillText(count > 0 ? count : "GO!", canvas.width/2, canvas.height/2);
            ctx.restore();
        } else if (gameState === 'DYING') {
            ctx.save();
            ctx.fillStyle = '#ff3366';
            ctx.font = 'bold 80px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(255, 50, 50, 0.8)';
            ctx.shadowBlur = 30;
            ctx.fillText("FAILURE", canvas.width/2, canvas.height/2);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeText("FAILURE", canvas.width/2, canvas.height/2);
            ctx.restore();
        }
    }

    function playTone(type) {
        if(isMuted) return;
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if (type === 'step') {
            osc.frequency.setValueAtTime(80, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if (type === 'sip') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(900, now + 0.2);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'fail') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.8);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.8);
            osc.start(); osc.stop(now + 0.8);
        } else if (type === 'win') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(523.25, now); 
            osc.frequency.setValueAtTime(659.25, now + 0.1); 
            osc.frequency.setValueAtTime(783.99, now + 0.2); 
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.setValueAtTime(0.2, now + 0.4);
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            osc.start(); osc.stop(now + 0.6);
        }
    }

    init();
</script>
</body>
</html>